# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
# | 31 22 |
# | 37 43 |
# | 51 86 |
#
# | 3 5 32 |
# | 2 4 6 |
# | -1 64 -8 |
#
# | 3 5 8 3 |
# | 8 3 7 1 |
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно. Первый элемент первой строки первой матрицы
# складываем с первым элементом первой строки второй матрицы и пр.


class Matrix:
    def __init__(self, lst):
        self.lst = lst

    def __str__(self):
        for row in self.lst:
            print((' '.join([str(e) for e in row])), end='\n')
        return''

    def __add__(self, other):
        for i in range(len(self.lst)):
            for j in range(len(other.lst[i])):
                self.lst[i][j] = self.lst[i][j] + other.lst[i][j]
        return Matrix.__str__(self)


matrix = Matrix([[31, 28, 22], [37, 85, 43], [51, 98, 86]])
matrix1 = Matrix([[10, 15, 20], [10, 20, 5], [30, 20, 10]])
print(matrix)

print(Matrix.__add__(matrix, matrix1))

# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название.
# К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры:
# размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма(2*H + 0.3).
# Проверить работу этих методов на реальных данных.
# Выполнить общий подсчёт расхода ткани. Проверить на практике полученные на этом уроке знания.
# Реализовать абстрактные классы для основных классов проекта и проверить работу декоратора @property.


from abc import ABC, abstractmethod


class Clothes(ABC):

    def __init__(self, param):
        self.param = param

    @property
    def fabric_consumption(self):
        return f'Затраченная ткань: {self.param / 6.5 + 0.5 + 2 * self.param + 0.3 :.2f}'

    @abstractmethod
    def abstract_method(self):
        return 'Smth vary abstract'


class Coat(Clothes):
    def fabric_consumption(self):
        return f'Затраченная ткань на пальто: {self.param / 6.5 + 0.5 :.2f}'

    def abstract_method(self):
        return 'Abstract method for coat class'


class Suit(Clothes):
    def fabric_consumption(self):
        return f'Затраченная ткань на костюм: {2 * self.param + 0.3 :.2f}'

    def abstract_method(self):
        return 'Abstract method for suit class'


coat = Coat(175)
suit = Suit(46)
print(coat.fabric_consumption())
print(suit.fabric_consumption())
print(coat.abstract_method())
print(suit.abstract_method())


# 3. Осуществить программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс «Клетка».
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число). В классе должны
# быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение
# (__mul__()), деление (__floordiv__, __truediv__()). Эти методы должны применяться только к клеткам и выполнять
# увеличение, уменьшение, умножение и округление до целого числа деления клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять, только если разность количества ячеек двух клеток больше
# нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки — произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Этот метод
# позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, а количество ячеек в ряду — 5. В этом случае метод make_order() вернёт
# строку: *****\n*****\n**.
# Или, количество ячеек клетки — 15, а количество ячеек в ряду равняется 5. Тогда метод make_order() вернёт строку:
# *****\n*****\n*****.


class Cell:

    def __init__(self, number):
        self.number = int(number)

    def __add__(self, other):
        return f'number of cells = {self.number + other.number}'

    def __sub__(self, other):
        if self.number - other.number < 0:
            return 'Не допустимый результат'
        else:
            return f'number of cells = {self.number - other.number}'

    def __truediv__(self, other):
        return f'number of cells = {self.number // other.number}'

    def __mul__(self, other):
        return f'number of cells = {self.number * other.number}'

    def make_order(self, row):
        res = ''
        for i in range(int(self.number / row)):
            res += '*' * row + ''\n''
        res += '*' * (self.number % row) + ''\n''
        return res






cell = Cell(5)
cell_2 = Cell(4)
print(cell + cell_2)
print(cell - cell_2)
print(cell / cell_2)
print(cell * cell_2)
print(cell.make_order(5))
